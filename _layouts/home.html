---
layout: default
---

<style>

  canvas {

    position: fixed;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    z-index: -1;

  }

  #text {

    z-index: 3;
    pointer-events: none;

  }

</style>


<div class="home">
  {%- if page.title -%}
    <h1 class="page-heading">{{ page.title }}</h1>
  {%- endif -%}

  {{ content | markdownify }}


  {% if site.paginate %}
    {% assign rawposts = paginator.posts %}
  {% else %}
    {% assign rawposts = site.posts %}
  {% endif %}

  <!-- Hide posts if front matter flag hide:true -->
  {% assign posts = ''|split:'' %}
  {% for post in rawposts %}
    {% if post.hide != true %}
      {% assign posts = posts|push:post%}
    {% endif %}
  {% endfor %}

  <!-- Sort posts by rank, then date -->
  {% assign grouped_posts = posts | group_by: "sticky_rank" | sort: "name", "last" %}
  {% assign sticky_posts = ''|split:'' %}
  {% assign non_sticky_posts = '' | split:'' %}

 
  {% for gp in grouped_posts %}
    {%- if gp.name == "" -%}
      {% assign non_sticky_posts = gp.items | sort: "date" | reverse %}
    {%- else %}
      {% assign sticky_posts = sticky_posts | concat: gp.items %}
    {%- endif -%}
  {% endfor %}

   <!-- Assemble final sorted posts array -->
  {% assign sticky_posts = sticky_posts | sort: "sticky_rank", "last" %}
  {% assign posts = sticky_posts | concat: non_sticky_posts %}

  {%- if posts.size > 0 -%}
    {%- if page.list_title -%}
      <h2 class="post-list-heading">{{ page.list_title }}</h2>
    {%- endif -%}
    <ul class="post-list">
      {%- assign date_format = site.minima.date_format | default: "%b %-d, %Y" -%}
      {%- for post in posts -%}
      <li>
        {%- if site.show_image -%}
            {%- include post_list_image_card.html -%}
        {% else %}
            {%- include post_list.html -%}
        {%- endif -%}
      </li>
      {%- endfor -%}
    </ul>

    {% if site.paginate and site.posts.size > site.paginate %}
      <div class="pager">
        <ul class="pagination">
        {%- if paginator.previous_page %}
          <li><a href="{{ paginator.previous_page_path | relative_url }}" class="previous-page">{{ paginator.previous_page }}</a></li>
        {%- else %}
          <li><div class="pager-edge">•</div></li>
        {%- endif %}
          <li><div class="current-page">{{ paginator.page }}</div></li>
        {%- if paginator.next_page %}
          <li><a href="{{ paginator.next_page_path | relative_url }}" class="next-page">{{ paginator.next_page }}</a></li>
        {%- else %}
          <li><div class="pager-edge">•</div></li>
        {%- endif %}
        </ul>
      </div>
    {%- endif %}

  {%- endif -%}
  <canvas id="text"></canvas>
  <script type="module" defer>

    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r99/three.module.min.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
    import * as dat from 'https://unpkg.com/dat.gui@0.7.7/build/dat.gui.module.js';
    
    const gui = new dat.GUI()

    function rotateVector(vector, tx, ty, tz) {

      let nVec = new THREE.Vector3(vector.x, vector.y, vector.z)

      // Z rotation\
      let tempX = nVec.x;
      nVec.x = nVec.x * Math.cos(tz) - nVec.y * Math.sin(tz);
      nVec.y = tempX * Math.sin(tz) + nVec.y * Math.cos(tz);
      // Z

      // Y rotation
      tempX = nVec.x;
      nVec.x = nVec.x * Math.cos(ty) + nVec.z * Math.sin(ty);
      // Y
      nVec.z = -tempX * Math.sin(ty) + nVec.z * Math.cos(ty);

      // X rotation
      // X
      let tempY = nVec.y;
      nVec.y = nVec.y * Math.cos(tx) - nVec.z * Math.sin(tx);
      nVec.z = tempY * Math.sin(tx) + nVec.z * Math.cos(tx);

      return nVec;

    }

    let bodies = [];

    let vector = new THREE.Vector3();
    
    const constants = {
    
      timeSteps: 10,
      timePerStep: 10000, //40000, // in seconds
      c: 0, // / fps
      gravity: 6.6743e-11,
      scale: 0.0000000001,
      AstronomicalObjectSizeMultiplier: 1,
      ObjectToTrack: undefined
    
    }

    let dummyCamera = new THREE.Vector3(0,0,200);

    let dt = 0;
    let oldTime = Date.now();

    let simulationTime = 946684800000; // Y2K

    let textCanvas = document.getElementById('text');
    let textctx = textCanvas.getContext('2d');
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 10000 );
    camera.position.z = 200
    
    const renderer = new THREE.WebGLRenderer( );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    window.addEventListener( 'resize', onWindowResize, false );

    function onWindowResize(){

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }
    
    let canvas = renderer.domElement;
    class AstronomicalObject {
    
      constructor(name, radius, mass, position, velocity) {
    
        const geometry = new THREE.SphereGeometry( radius * constants.scale * constants.AstronomicalObjectSizeMultiplier, 32, 32 );
        const material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
        this.body = new THREE.Mesh( geometry, material );
        bodies.push( this );
        scene.add( this.body );
        this.body.radius = radius * constants.scale * constants.AstronomicalObjectSizeMultiplier;
        this.body.position.x = 0;
        this.name = name;
        this.body.position.y = 0;
        this.body.position.z = 0;
        this.mass = mass;
        this.trailPoints = [],
        this.line = false;
        this.motion = {
    
          position: new THREE.Vector3(0, 0, 0),
          velocity: new THREE.Vector3(0, 0, 0),
          acceleration: new THREE.Vector3(0, 0, 0)
    
        }
    
        if (position) this.motion.position = new THREE.Vector3(...position);
        if (velocity) this.motion.velocity = new THREE.Vector3(...velocity);
    
      }
    
    }

    function distance(vector1, vector2) {

      let xDiff = bodies[x].motion.position.x - bodies[y].motion.position.x;
      let yDiff = bodies[x].motion.position.y - bodies[y].motion.position.y;
      let zDiff = bodies[x].motion.position.z - bodies[y].motion.position.z;

      let scalar = Math.sqrt((xDiff)**2 + (yDiff)**2 + (zDiff)**2) || 0;

    }
    
    let sun = new AstronomicalObject('Sun', 6.95700e8, 1.989e30, [0, 0, 0], [0, 0, 0]);
    sun.body.material.color.set('yellow');

    let mercury = new AstronomicalObject('Mercury', 2440500, 3.3010e23, [68426000000, 0, 0], [0, 47360, 0]);
    mercury.body.material.color.set('brown');
    mercury.motion.position = rotateVector(mercury.motion.position, 0, 0, 245.5 * Math.PI / 180);
    mercury.motion.velocity = rotateVector(mercury.motion.velocity, 0, 7.005 * Math.PI / 180, 245.5 * Math.PI / 180);

    let venus = new AstronomicalObject('Venus', 6051800, 4.8673e24, [107480000000, 0, 0], [0, 35020, 0]);
    venus.body.material.color.set('orange');
    venus.motion.position = rotateVector(venus.motion.position, 0, 0, 182 * Math.PI / 180);
    venus.motion.velocity = rotateVector(venus.motion.velocity, 0, 3.3947 * Math.PI / 180, 182 * Math.PI / 180);
    
    let earth = new AstronomicalObject('Earth', 6371000, 5.972e24, [151000000000, 0, 0], [0, 2.978589e4, 0]); //m/s  
    earth.body.material.color.set('green');
    earth.motion.position = rotateVector(earth.motion.position, 0, 0, 109 * Math.PI / 180);
    earth.motion.velocity = rotateVector(earth.motion.velocity, 0, 0, 109 * Math.PI / 180);

    // let moon = new AstronomicalObject(1737400, 7.347e22, [151000000000 + 384399000, 0, 0], [0, 29800, 1022]);
    // moon.body.material.color.set('white');

    let mars = new AstronomicalObject('Mars', 3389500, 6.39e23, [213140000000, 0, 0], [0, 24070, 0]);
    mars.body.material.color.set('red');
    mars.motion.position = rotateVector(mars.motion.position, 0, 0, -1 * Math.PI / 180);
    mars.motion.velocity = rotateVector(mars.motion.velocity, 0, 1.851 * Math.PI / 180, -1 * Math.PI / 180);

    let jupiter = new AstronomicalObject('Jupiter', 66854000, 1.89813e27, [741690000000, 0, 0], [0, 13060, 0]);
    jupiter.body.material.color.set('pink');
    jupiter.motion.position = rotateVector(jupiter.motion.position, 0, 0, 40 * Math.PI / 180);
    jupiter.motion.velocity = rotateVector(jupiter.motion.velocity, 0, 1.305 * Math.PI / 180, 40 * Math.PI / 180);

    let saturn = new AstronomicalObject('Saturn', 60268000, 5.6832e26, [1.4737e12, 0, 0], [0, 9680, 0]);
    saturn.body.material.color.set('purple');
    saturn.motion.position = rotateVector(saturn.motion.position, 0, 0, 50 * Math.PI / 180);
    saturn.motion.velocity = rotateVector(saturn.motion.velocity, 0, 2.484 * Math.PI / 180, 50 * Math.PI / 180);

    let uranus = new AstronomicalObject('Uranus', 25559000, 8.6811e25, [2.9444e+12, 0, 0], [0, 6800, 0]);
    uranus.body.material.color.set('blue');
    uranus.motion.position = rotateVector(uranus.motion.position, 0, 0, 325 * Math.PI / 180);
    uranus.motion.velocity = rotateVector(uranus.motion.velocity, 0, 0.770 * Math.PI / 180, 325 * Math.PI / 180);

    let neptune = new AstronomicalObject('Neptune', 24341000, 1.02409e26, [4.558857e12, 0, 0], [0, 5430, 0]);
    neptune.body.material.color.set('magenta');
    neptune.motion.position = rotateVector(neptune.motion.position, 0, 0, 315 * Math.PI / 180);
    neptune.motion.velocity = rotateVector(neptune.motion.velocity, 0, 1.769 * Math.PI / 180, 315 * Math.PI / 180);

    let pluto = new AstronomicalObject('Pluto', 1188000, 1.02409e26, [7.304326e12, 0, 0], [0, 3710, 0]);
    pluto.body.material.color.set('white');
    pluto.motion.position = rotateVector(pluto.motion.position, 0, 0, 270 * Math.PI / 180);
    pluto.motion.velocity = rotateVector(pluto.motion.velocity, 0, 17.14 * Math.PI / 180, 270 * Math.PI / 180);

    // WHICH OBJECT TO TRACK
    constants.ObjectToTrack = sun;

    function createPathStrings(filename) {
    const baseFilename = "https://tristancopley.github.io/dnhs-blog/images/skybox/";
    const fileType = ".png";
    const sides = ["right", "left", "top", "bottom", "front", "back"];

    const pathStings = sides.map(side => {

        return baseFilename + side + fileType;

    });

    return pathStings;

    }

    let skyboxImage = "space";
    function createMaterialArray(filename) {
    const skyboxImagepaths = createPathStrings(filename);
    const materialArray = skyboxImagepaths.map(image => {

        let texture = new THREE.TextureLoader().load(image);

        return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });

    });

    return materialArray;

    }

    const materialArray = createMaterialArray(skyboxImage);
    let skyboxGeo = new THREE.BoxGeometry(50000000000000 * constants.scale, 50000000000000 * constants.scale, 50000000000000 * constants.scale);
    let skybox = new THREE.Mesh(skyboxGeo, materialArray);
    scene.add(skybox);

    let trails = [];
    
    renderer.shadowMap.enabled = true;
    
    const pointLight = new THREE.PointLight( 0xffffff, 3);
    pointLight.position.x = 0;
    pointLight.position.y = 0;
    pointLight.position.z = 0;
    pointLight.castShadows = true;
    scene.add( pointLight );
    
    const aLight = new THREE.AmbientLight( 0xffffff, 0.8);
    scene.add( aLight );
    
    const controls = new OrbitControls(camera, renderer.domElement);

    controls.autoRotate = true;
    
    const constantsFolder = gui.addFolder('Constants');
    constantsFolder.add(constants, 'timeSteps', 0, 365);
    constantsFolder.add(constants, 'timePerStep', 0, 86400);
    constantsFolder.open();
    
    function animate() {

      dt = Date.now() - oldTime || 1;
      oldTime = Date.now();

      constants.simTimePerStep = constants.timePerStep / (1000 / (dt || 1));

      simulationTime += (constants.simTimePerStep * constants.timeSteps ** 2) * 1000;
    
      for (let t = 0; t < constants.timeSteps ** 2; t++) {        
    
          if (constants.timeSteps === 0) continue;
    
          for(let x = 0; x < bodies.length; x++) {
    
              for(let y = x + 1; y < bodies.length; y++) {
                  
                let xDiff = bodies[x].motion.position.x - bodies[y].motion.position.x;
                let yDiff = bodies[x].motion.position.y - bodies[y].motion.position.y;
                let zDiff = bodies[x].motion.position.z - bodies[y].motion.position.z;
    
                let scalar = Math.sqrt((xDiff)**2 + (yDiff)**2 + (zDiff)**2) || 1;
                let force = constants.gravity * (bodies[x].mass * bodies[y].mass) / (scalar**2);
    
                bodies[x].motion.acceleration.x -= (xDiff / scalar * force) / bodies[x].mass;
                bodies[x].motion.acceleration.y -= (yDiff / scalar * force) / bodies[x].mass;
                bodies[x].motion.acceleration.z -= (zDiff / scalar * force) / bodies[x].mass;
    
                bodies[y].motion.acceleration.x += (xDiff / scalar * force) / bodies[y].mass;
                bodies[y].motion.acceleration.y += (yDiff / scalar * force) / bodies[y].mass;
                bodies[y].motion.acceleration.z += (zDiff / scalar * force) / bodies[y].mass;
    
              }   
    
            }
      
            for(let z = 0; z < bodies.length; z++) {
      
              bodies[z].motion.velocity.x += bodies[z].motion.acceleration.x * constants.simTimePerStep;
              bodies[z].motion.velocity.y += bodies[z].motion.acceleration.y * constants.simTimePerStep;
              bodies[z].motion.velocity.z += bodies[z].motion.acceleration.z * constants.simTimePerStep;

              bodies[z].motion.position.x += bodies[z].motion.velocity.x * constants.simTimePerStep;
              bodies[z].motion.position.y += bodies[z].motion.velocity.y * constants.simTimePerStep;
              bodies[z].motion.position.z += bodies[z].motion.velocity.z * constants.simTimePerStep;

              bodies[z].motion.acceleration = new THREE.Vector3(0, 0, 0);
      
            }
      
      }
      
      for(let z = 0; z < bodies.length; z++) {
      
        bodies[z].body.position.x = bodies[z].motion.position.x * constants.scale;
        bodies[z].body.position.y = bodies[z].motion.position.y * constants.scale;
        bodies[z].body.position.z = bodies[z].motion.position.z * constants.scale;
      
      }
      
      let cameraLock = {

          x: 0,
          y: 0,
          z: 0

      };

    cameraLock = sun.body.position;

    for(let z = 0; z < bodies.length; z++) {
    
    /* finalCameraPositionX += bodies[z].body.position.x;
    finalCameraPositionY += bodies[z].body.position.y;
    finalCameraPositionZ += bodies[z].body.position.z; */
      
    if (constants.timeSteps > 0) {

        bodies[z].trailPoints.push(new THREE.Vector3(bodies[z].body.position.x, bodies[z].body.position.y, bodies[z].body.position.z));
        if (bodies[z].trailPoints.length > 1000) bodies[z].trailPoints.shift();
    
        // CREATE THE LINE
        if(typeof bodies[z].line == 'object') scene.remove(bodies[z].line);
        let line = new THREE.Line( new THREE.BufferGeometry().setFromPoints( bodies[z].trailPoints ), new THREE.LineBasicMaterial({color: 0xff00ff}));
        line.material.color.set(bodies[z].body.material.color)
        bodies[z].line = line;
        scene.add(line);

      }
    
    }
      
      camera.position.x -= controls.target.x - cameraLock.x;
      camera.position.y -= controls.target.y - cameraLock.y;
      camera.position.z -= controls.target.z - cameraLock.z;
      
      pointLight.position.x = cameraLock.x;
      pointLight.position.y = cameraLock.y;
      pointLight.position.z = cameraLock.z;
      
      controls.target = new THREE.Vector3(cameraLock.x, cameraLock.y, cameraLock.z);

      controls.update();

      /* camera.near = 0
      camera.far = 0; */

      skybox.position.x = camera.position.x;
      skybox.position.y = camera.position.y;
      skybox.position.z = camera.position.z;

      textCanvas.width = canvas.width;
      textCanvas.height = canvas.height;

      textctx.font = "12px Courier New";
      textctx.fillStyle = "white";

      for(let z = 0; z < bodies.length; z++) {

        vector.set( bodies[z].body.position.x + bodies[z].body.radius, bodies[z].body.position.y + bodies[z].body.radius, bodies[z].body.position.z + bodies[z].body.radius);

        // map to normalized device coordinate (NDC) space
        vector.project( camera );

        // map to 2D screen space
        vector.x = Math.round( (   vector.x + 1 ) * canvas.width  / 2 );
        vector.y = Math.round( ( - vector.y + 1 ) * canvas.height / 2 );

        if(vector.z < 1) textctx.fillText(bodies[z].name, vector.x, vector.y);
      
      }

      textctx.font = "20px Courier New";
      textctx.fillStyle = "white";
      textctx.fillText(new Date(simulationTime), 20, 20);

      // // Website mode
      // constants.timePerStep = Math.abs(Math.sin(Date.now()/10000) * 126400) + 40000;
      // constants.timeSteps = 10;

      renderer.render( scene, camera );
    
      requestAnimationFrame( animate );

    }
    
    animate();
          
    </script>
</div>