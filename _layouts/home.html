---
layout: default
---

<style>

  canvas {

      position: fixed;
      z-index: -1;
      width: 10vw;
      height: 100vh;
    
  }

</style>


<div class="home">
  {%- if page.title -%}
    <h1 class="page-heading">{{ page.title }}</h1>
  {%- endif -%}

  {{ content | markdownify }}


  {% if site.paginate %}
    {% assign rawposts = paginator.posts %}
  {% else %}
    {% assign rawposts = site.posts %}
  {% endif %}

  <!-- Hide posts if front matter flag hide:true -->
  {% assign posts = ''|split:'' %}
  {% for post in rawposts %}
    {% if post.hide != true %}
      {% assign posts = posts|push:post%}
    {% endif %}
  {% endfor %}

  <!-- Sort posts by rank, then date -->
  {% assign grouped_posts = posts | group_by: "sticky_rank" | sort: "name", "last" %}
  {% assign sticky_posts = ''|split:'' %}
  {% assign non_sticky_posts = '' | split:'' %}

 
  {% for gp in grouped_posts %}
    {%- if gp.name == "" -%}
      {% assign non_sticky_posts = gp.items | sort: "date" | reverse %}
    {%- else %}
      {% assign sticky_posts = sticky_posts | concat: gp.items %}
    {%- endif -%}
  {% endfor %}

   <!-- Assemble final sorted posts array -->
  {% assign sticky_posts = sticky_posts | sort: "sticky_rank", "last" %}
  {% assign posts = sticky_posts | concat: non_sticky_posts %}

  {%- if posts.size > 0 -%}
    {%- if page.list_title -%}
      <h2 class="post-list-heading">{{ page.list_title }}</h2>
    {%- endif -%}
    <ul class="post-list">
      {%- assign date_format = site.minima.date_format | default: "%b %-d, %Y" -%}
      {%- for post in posts -%}
      <li>
        {%- if site.show_image -%}
            {%- include post_list_image_card.html -%}
        {% else %}
            {%- include post_list.html -%}
        {%- endif -%}
      </li>
      {%- endfor -%}
    </ul>

    {% if site.paginate and site.posts.size > site.paginate %}
      <div class="pager">
        <ul class="pagination">
        {%- if paginator.previous_page %}
          <li><a href="{{ paginator.previous_page_path | relative_url }}" class="previous-page">{{ paginator.previous_page }}</a></li>
        {%- else %}
          <li><div class="pager-edge">•</div></li>
        {%- endif %}
          <li><div class="current-page">{{ paginator.page }}</div></li>
        {%- if paginator.next_page %}
          <li><a href="{{ paginator.next_page_path | relative_url }}" class="next-page">{{ paginator.next_page }}</a></li>
        {%- else %}
          <li><div class="pager-edge">•</div></li>
        {%- endif %}
        </ul>
      </div>
    {%- endif %}

  {%- endif -%}
  
	<script type="module" defer>

import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r99/three.module.min.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
import * as dat from 'https://unpkg.com/dat.gui@0.7.7/build/dat.gui.module.js';

const gui = new dat.GUI()


let bodies = [];

const constants = {

  timeSteps: 100,
  gravity: 6.6743e-11,
  scale: 0.000000001,

}

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 4000 );
camera.position.z = 200

const renderer = new THREE.WebGLRenderer( );
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

class AstronomicalObject {

  constructor(radius, mass, position, velocity) {

    const geometry = new THREE.SphereGeometry( radius * constants.scale, 32, 16 );
    const material = new THREE.MeshPhongMaterial( { color: 0xffffff } );
    this.body = new THREE.Mesh( geometry, material );
    bodies.push( this );
    scene.add( this.body );
    this.body.position.x = 0;
    this.body.position.y = 0;
    this.body.position.z = 0;
    this.mass = mass;
    this.trailPoints = [],
    this.line = false;
    this.motion = {

      position: {

        x: 0,
        y: 0,
        z: 0 

      },

      velocity: {

        x: 0,
        y: 0,
        z: 0 

      }

    }

    if (position) this.motion.position = new THREE.Vector3(...position);
    if (velocity) this.motion.velocity = new THREE.Vector3(...velocity);

  }

}

let sun = new AstronomicalObject(6.95700e8, 1.989e30, [0, 0, 0], [0, 0, 0]);
sun.body.material.color.set('yellow');

let earth = new AstronomicalObject(6371000, 5.972e24, [151000000000, 0, 0], [0, 29800, 0]);
earth.body.material.color.set('green');

let moon = new AstronomicalObject(1737400, 7.347e22, [151000000000 + 384399000, 0, 0], [0, 29800 + 1022, 0])

let trails = [];

renderer.shadowMap.enabled = true;

const pointLight = new THREE.PointLight( 0xffffff, 3);
pointLight.position.x = 0;
pointLight.position.y = 0;
pointLight.position.z = 0;
pointLight.castShadows = true;
scene.add( pointLight );

const aLight = new THREE.AmbientLight( 0xffffff, 0.8);
scene.add( aLight );

const controls = new OrbitControls(camera, renderer.domElement);

const constantsFolder = gui.addFolder('Constants');
constantsFolder.add(constants, 'timeSteps', 0, 10000);
constantsFolder.open();

function animate() {

  for (let t = 0; t < constants.timeSteps; t++) {        

      if (constants.timeSteps === 0) continue;

      for(let x = 0; x < bodies.length; x++) {

          for(let y = x + 1; y < bodies.length; y++) {
              
            let xDiff = bodies[x].motion.position.x-bodies[y].motion.position.x;
            let yDiff = bodies[x].motion.position.y-bodies[y].motion.position.y;
            let zDiff = bodies[x].motion.position.z-bodies[y].motion.position.z;

            let scalar = Math.sqrt((xDiff)**2 + (yDiff)**2 + (zDiff)**2) || 1;
            let force = constants.gravity * (bodies[x].mass * bodies[y].mass) / (scalar**2);

            bodies[x].motion.velocity.x -= (xDiff / scalar * force) / bodies[x].mass;
            bodies[x].motion.velocity.y -= (yDiff / scalar * force) / bodies[x].mass;
            bodies[x].motion.velocity.z -= (zDiff / scalar * force) / bodies[x].mass;

            bodies[y].motion.velocity.x += (xDiff / scalar * force) / bodies[y].mass;
            bodies[y].motion.velocity.y += (yDiff / scalar * force) / bodies[y].mass;
            bodies[y].motion.velocity.z += (zDiff / scalar * force) / bodies[y].mass;

          }   

      }

      for(let z = 0; z < bodies.length; z++) {

        bodies[z].motion.position.x += bodies[z].motion.velocity.x;
        bodies[z].motion.position.y += bodies[z].motion.velocity.y;
        bodies[z].motion.position.z += bodies[z].motion.velocity.z;

      }   

}

for(let z = 0; z < bodies.length; z++) {

  bodies[z].body.position.x = bodies[z].motion.position.x * constants.scale;
  bodies[z].body.position.y = bodies[z].motion.position.y * constants.scale;
  bodies[z].body.position.z = bodies[z].motion.position.z * constants.scale;

}

let finalCameraPositionX = 0;
let finalCameraPositionY = 0;
let finalCameraPositionZ = 0;

for(let z = 0; z < bodies.length; z++) {

  finalCameraPositionX += bodies[z].body.position.x;
  finalCameraPositionY += bodies[z].body.position.y;
  finalCameraPositionZ += bodies[z].body.position.z;

  bodies[z].trailPoints.push(new THREE.Vector3(bodies[z].body.position.x, bodies[z].body.position.y, bodies[z].body.position.z));
  if (bodies[z].trailPoints.length > 1000) bodies[z].trailPoints.shift();

  // CREATE THE LINE
  if(typeof bodies[z].line == 'object') scene.remove(bodies[z].line);
  let line = new THREE.Line( new THREE.BufferGeometry().setFromPoints( bodies[z].trailPoints ), new THREE.LineBasicMaterial({color: 0xff00ff}));
  line.material.color.set(bodies[z].body.material.color)
  bodies[z].line = line;
  scene.add(line);

}

camera.position.x -= controls.target.x - finalCameraPositionX / bodies.length //plane.position.x = pointLight.position.x = finalCameraPositionX / bodies.length;
camera.position.y -= controls.target.y - finalCameraPositionY / bodies.length //plane.position.y = pointLight.position.y = finalCameraPositionY / bodies.length;
camera.position.z -= controls.target.z - finalCameraPositionZ / bodies.length //plane.position.z = pointLight.position.z = finalCameraPositionZ / bodies.length;

pointLight.position.x = finalCameraPositionX / bodies.length;
pointLight.position.y = finalCameraPositionY / bodies.length;
pointLight.position.z = finalCameraPositionZ / bodies.length;

controls.target = new THREE.Vector3(finalCameraPositionX / bodies.length, finalCameraPositionY / bodies.length, finalCameraPositionZ / bodies.length);

  controls.update();

  renderer.render( scene, camera );

  requestAnimationFrame( animate );

}

animate();
      
</script>
</div>